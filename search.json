[
  {
    "objectID": "posts/qutip-simulations/index.html",
    "href": "posts/qutip-simulations/index.html",
    "title": "Using QuTip",
    "section": "",
    "text": "QuTip is a superb Python library to simulate the dynamics of open quantum systems\n\nimport scipy\nimport numpy as np\nfrom qutip import Qobj, mesolve\nfrom qutip import basis, tensor\nfrom qutip.qip.operations import cnot\n\n# Basis states\nzero = basis(2,0)\none = basis(2,1)\n\n# |10&gt;\none_zero = tensor(one, zero)\n\n# CNOT\nhamiltonian = cnot().full()\n\n# e^itH\nu_generator = Qobj(1j * scipy.linalg.logm(hamiltonian), dims=[[2] * 2] * 2)\n\n# Time range 0.0 -&gt; 1.0\ntimes = np.arange(0, 1.1, 0.1)\n\n# \\psi = H\\psi_0\nevolution = mesolve(u_generator, one_zero, times)\n\n\nevolution.states[0]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [0.]\n [1.]\n [0.]]\n\n\nThis is our initial state. Where will it be at the next step of our evolution?\n\nevolution.states[1]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.        +0.j        ]\n [0.        +0.j        ]\n [0.97552824+0.15450855j]\n [0.02447175-0.15450855j]]\n\n\nAnd at the end?\n\nevolution.states[-1]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.00000000e+00+0.00000000e+00j]\n [0.00000000e+00+0.00000000e+00j]\n [1.07316277e-06+9.88099162e-07j]\n [1.00000000e+00-9.88099162e-07j]]\n\n\nExactly, we have been able to simulate the whole evolution keeping the intermediate states to further study them. Neat.\nWe can try to make it closer to the example we performed from scratch to better understand how it works.\n\nfrom qutip import basis, tensor\n\none = basis(2,1)\nzero = basis(2,0)\n\none_zero = tensor(one, zero) # |10&gt;\none_zero\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [0.]\n [1.]\n [0.]]\n\n\n\nfrom qutip.qip.operations import cnot\n\ncnot_matrix = cnot().full()\ncnot_matrix\n\narray([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n\n\nIn fact, it allows us to do more than just the simple operations we envisioned. For example, we could generate the whole evolution over a period of time of the \\(U\\) unitary generated for our Hamiltonian.\n\nfrom qutip import identity\nfrom qutip.qip.operations import hadamard_transform\n\n# hamiltonian\nhamiltonian =  cnot() * tensor(hadamard_transform(1), identity(2))\nhamiltonian\n\nQuantum object: dims=[[2, 2], [2, 2]], shape=(4, 4), type='oper', dtype=Dense, isherm=False\nQobj data =\n[[ 0.70710678  0.          0.70710678  0.        ]\n [ 0.          0.70710678  0.          0.70710678]\n [ 0.          0.70710678  0.         -0.70710678]\n [ 0.70710678  0.         -0.70710678  0.        ]]\n\n\n\nimport numpy as np\nimport scipy\nfrom qutip import Qobj, mesolve\n\n# Initial state\ninit_state = tensor(zero, zero) # |00&gt;\n\n# e^itH\nu_generator = Qobj(1j * scipy.linalg.logm(hamiltonian.full()), dims=[[2] * 2] * 2)\n\n# Time range\ntimes = np.arange(0, 1.1, 0.1)\nevolution = mesolve(u_generator, init_state, times)\n\n\nevolution.states[0]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[1.]\n [0.]\n [0.]\n [0.]]\n\n\n\nfrom qiskit.visualization import array_to_latex\n\npsi = np.round(evolution.states[-1].full(), decimals = 5)\n\narray_to_latex(array=psi, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n0.70711  \\\\\n0  \\\\\n0  \\\\\n0.70711  \\\\\n\\end{bmatrix}\n\\]\n\n\nWell, having a theoretical framework may be a good option for simulating and doing some local experimentation but that will reach soon limitations when trying to scale it up. Our classical device won’t be able to perform the whole system calculations and we might need to switch to actual quantum computers doing those. Therefore, we need to find a way to o so.\nThis is why some manufacturers have invested time and effort on creating open-source frameworks to be adopted by the community (and position themselves). Companies such as IBM or AWS have leveraged their own version that also allows for these programs to be sent to an end device that will perform the set of operations."
  },
  {
    "objectID": "posts/welcome/welcome.html",
    "href": "posts/welcome/welcome.html",
    "title": "Welcome",
    "section": "",
    "text": "Hi! My name is Iraitz Montalban and I love to mess around with technology.\nActually I am using this blog to explore new-ish technology and explain things so other can benefit from it and meanwhile, I can get a better understanding on it. So, sometimes I will be talking about Python or Julia and the controversy around which one is best, will be exploring really basic stuff so I can refresh my memory, maybe review a paper or simply just play around with a new tool.\nI will just let my curiosity drive this thing wherever it takes me. Happy that you want to join me."
  },
  {
    "objectID": "posts/quantum-gates/index.html",
    "href": "posts/quantum-gates/index.html",
    "title": "Quantum gates",
    "section": "",
    "text": "Once we collected some qubits, we may want to do something with those. The natural way to evolve the state you may have in those qubits is by using some operator.\nIn general we used Hamiltonians for that, the description of how our state should move. We need to translate those dynamics to gates so that we can act upon our qubits."
  },
  {
    "objectID": "posts/quantum-gates/index.html#time-evolution-postulate",
    "href": "posts/quantum-gates/index.html#time-evolution-postulate",
    "title": "Quantum gates",
    "section": "Time Evolution Postulate",
    "text": "Time Evolution Postulate\nA pure state \\(|\\psi(t_0)\\rangle\\) in a Hilbert space \\(\\mathcal{H}\\) evolves to another state \\(|\\psi(t)\\rangle\\) is given by the time evolution operator \\(U(t,t_0)\\)\n\\[\n|\\psi(t)\\rangle = U(t,t_0)|\\psi(t_0)\\rangle\n\\]\nwhere \\(U(t,t_0)\\) is the unitary transformation on the initial state of a closed system (with special case \\(U(t_0,t_0)=I\\)). The time evolution is governed by the Schrödinger equation\n\\[\ni\\frac{d}{dt}|\\psi(t)\\rangle = \\hat{H}|\\psi(t)\\rangle \\rightarrow |\\psi(t)\\rangle = e^{-i\\hat{H}t}|\\psi(0)\\rangle\n\\]\nhere \\(\\hat{H}\\) is a self adjoint operator also known as the Hamiltonian. \\(\\hat{H}\\) is an observable associated to the energy of the system and governs the dynamics of a given state relating to previously mentioned \\(U\\) as \\(U(t) = e^{-(i/\\hbar)t\\hat{H}}\\) following Stone’s theorem.\nIn general, we can see this evolution operators as matrices applied to the same dimensional space of the quantum state it will be affected by. Let’s check some simple but useful examples we will be using for our computing tasks."
  },
  {
    "objectID": "posts/quantum-gates/index.html#the-hall-of-gates",
    "href": "posts/quantum-gates/index.html#the-hall-of-gates",
    "title": "Quantum gates",
    "section": "The Hall of Gates",
    "text": "The Hall of Gates\nAs in classical computing, some key gates need to be known. The \\(NAND\\) being an universal boolean logic gate as it can create all the other options required to render boolean logic, we should introduce some of the core gates when talking about quantum computing and the universality of those gates.\n\nNOT-gate (X)\nThe not gate (\\(X\\) as the operator gate and \\(\\sigma_x\\) if expressed as a Pauli matrix) is one of the most basic concepts in computing. A classical operation that takes the bit in a position (0 or 1) to its opposite. But, quantum not extends that basic concept to the complexity of the quantum regime. The operator can be represented by a matrix like the following one:\n\\[\nX = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\n\\]\nThen, the operation \\(X|0\\rangle = |1\\rangle\\) can be validated by the simple multiplication of the matrix of the gate by the quantum state:\n\\[\nX|0\\rangle = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n0 \\\\\n1\n\\end{array}\n\\right] = |1\\rangle\n\\]\nBut if we perform this very simple example with the generic case for \\(|\\psi\\rangle\\)\n\\[\nX|\\psi\\rangle = X(\\alpha|0\\rangle + \\beta |1\\rangle) = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n\\beta \\\\\n\\alpha\n\\end{array}\n\\right] = \\beta|0\\rangle + \\alpha |1\\rangle = |\\phi\\rangle\n\\]\nwe have basically created a new state where its outcome probabilities have been shifted. Therefore, the \\(X\\) operation can be used to shift the state ratter than perform a mere coin flipping. This gets more interesting looking at some specific gates like the Hadamard gate.\n\n\nHadamard (H)\nIts matrix representation is\n\\[\nH = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\n\\]\nAnd its effect…\n\\[\nH|0\\rangle = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{c}\n1 \\\\\n1\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{1}{\\sqrt{2}}|1\\rangle = |+\\rangle\n\\]\nbasically it allows as to switch the axis of the bloch sphere and work on the superposition of the states on the \\(Z\\) axis.\n\n\n\n\nBloch sphere"
  },
  {
    "objectID": "posts/quantum-gates/index.html#rotating-quantum-states",
    "href": "posts/quantum-gates/index.html#rotating-quantum-states",
    "title": "Quantum gates",
    "section": "Rotating quantum states",
    "text": "Rotating quantum states\nIn essence, we will see that many gates what they offer us is simply rotations over the three main axes of the bloch sphere:\n\\[\nR_x(\\theta) = \\left(\n    \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -i\\sin(\\frac{\\theta}{2}) \\\\\n        -i\\sin(\\frac{\\theta}{2}) & \\cos(\\frac{\\theta}{2})\n    \\end{array}\n    \\right)\n\\]\n\\[\nR_y(\\theta) = \\left(\n    \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -\\sin(\\frac{\\theta}{2}) \\\\\n        \\sin(\\frac{\\theta}{2}) & \\cos(\\frac{\\theta}{2})\n    \\end{array}\n    \\right)\n\\]\n\\[\nR_z(\\theta) = \\left(\n    \\begin{array}{cc}\n        e^{-i\\frac{\\theta}{2}} & 0 \\\\\n        0 & e^{i\\frac{\\theta}{2}}\n    \\end{array}\n    \\right)\n\\]\nmaking the general case \\(R_M(\\theta) = \\exp^{(−i\\theta M/2)}\\) where \\(M \\in \\{X,Y,Z\\};\\) being those three the Pauli gates the Pauli matrices \\(\\sigma_x, \\sigma_y \\text{ and } \\sigma_z\\). Actually the literature will quote a more generic case which will be given by the following gate operator\n\\[\nU(\\theta, \\phi, \\lambda) = \\left( \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -e^{i\\lambda}\\sin(\\frac{\\theta}{2})\\\\\n        e^{i\\phi}\\sin(\\frac{\\theta}{2}) & e^{i(\\phi+\\lambda)}\\cos(\\frac{\\theta}{2})\n    \\end{array} \\right)\n\\]\nwhich maps to previous gates following the relationship \\(U(\\theta,0,0) = R_y(\\theta)\\), \\(U(0,0,\\lambda) = R_z(\\lambda)\\) and \\(U(\\theta,-\\frac{\\pi}{2},\\frac{\\pi}{2}) = R_x(\\theta)\\)"
  },
  {
    "objectID": "posts/quantum-gates/index.html#native-gates",
    "href": "posts/quantum-gates/index.html#native-gates",
    "title": "Quantum gates",
    "section": "Native gates",
    "text": "Native gates\nQuantum Computing as a mathematical framework that allows for all kind of gates to be designed but in many cases depending on the manufacturer of the device the set of gates we can employ may differ. We will need to find the combination of gates that will produce our desired action by using the gates each device is equipped with. Also called native gates.\nThe native gate set is the gate set, one and two-qubit gates, that should be used to translate any gate from the mathematical framework to be translated or better expressed, transpiled to those.\nOur circuit:\n\n\n\n\nGHZ state\n\n\n\n\\(H\\) represents the Hadamard gate and the other two blue ones, the Control-NOT gate as the basis for generating entangled states.\nNo device can implement natively at least to the best of our knowledge. Therefore, in order to apply that gate own needs to apply native gates that produce the same action or unitary matrix.\nWhat can run on IBM devices:\n\n\n\n\nGHZ transpiled\n\n\n\nWe will see this in more detail later when we review hardware providers and their actual implementation."
  },
  {
    "objectID": "posts/quantum-gates/index.html#control-not-cnot",
    "href": "posts/quantum-gates/index.html#control-not-cnot",
    "title": "Quantum gates",
    "section": "Control-NOT (CNOT)",
    "text": "Control-NOT (CNOT)\nOne interesting gate to be implemented in this regime is the control not or CNOT gate. This acts on the target qubit only if the first qubit is at \\(|1\\rangle\\) state. It does not require any classical measurement or observation, meaning the control qubit still holds its quantumness after gate operation. This is critical to the good functioning of the system otherwise any classical action would affect the quantum state making it purely classical.\n\\[\nCNOT|00\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n1 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{array}\n\\right] = |00\\rangle\n\\]\n\\[\nCNOT|10\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n0 \\\\\n0 \\\\\n1 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n0 \\\\\n0 \\\\\n0 \\\\\n1\n\\end{array}\n\\right] = |11\\rangle\n\\]\nBut what does there happen when it gets applied to a superposed state.\n\\[\nCNOT|+0\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\frac{1}{\\sqrt{2}} \\\\\n0 \\\\\n\\frac{1}{\\sqrt{2}} \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n\\frac{1}{\\sqrt{2}} \\\\\n0 \\\\\n0 \\\\\n\\frac{1}{\\sqrt{2}}\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\n\\]\nQuite interesting. Have you tried decomposing this state into the tensor product of the quantum state of the two qubits? Fine, because it is not possible. This is what it is called an entangled state. One particular benefit of this states is that by measuring only one of those qubits we know the value of the second one without any need for measurement."
  },
  {
    "objectID": "posts/quantum-gates/index.html#entanglement",
    "href": "posts/quantum-gates/index.html#entanglement",
    "title": "Quantum gates",
    "section": "Entanglement",
    "text": "Entanglement\nEntangled states are critical for some of the quantum algortihms allowing us to outperform (theoretically at least) classical computing. The most basic (and probably best known) entangled states are the Bell states or EPR paris.\n\\[\n|\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\quad |\\Phi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle - |11\\rangle)\n\\]\n\\[\n|\\Psi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|01\\rangle + |10\\rangle) \\quad |\\Psi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|10\\rangle - |10\\rangle)\n\\]\nEntangled states are behind some of the key algorithms in communication protocols such as Quantum Teleportation or Superdense coding or behind the post-quantum cryptography proposals, like the Quantum Key Distribution. But they are also relevant for computations as we will see in the following sections.\nI know, too much theory. Let’s try to execute some code to make it more clear."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! This is Iraitz, data and computing enthusiast. That is why you will see plenty things about Data Engineering, Scientific Computing and Machine Learning around here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Iraitz’s blog",
    "section": "",
    "text": "Coding my own simulator\n\n\n\nqc\n\ncode\n\n\n\n\n\n\n\n\n\nJun 24, 2025\n\n\nIraitz Montalban\n\n\n\n\n\n\n\n\n\n\n\n\nUsing QuTip\n\n\n\nqc\n\ncode\n\n\n\n\n\n\n\n\n\nJun 24, 2025\n\n\nIraitz Montalban\n\n\n\n\n\n\n\n\n\n\n\n\nQuantum gates\n\n\n\nqc\n\ncode\n\n\n\n\n\n\n\n\n\nJun 15, 2025\n\n\nIraitz Montalban\n\n\n\n\n\n\n\n\n\n\n\n\nGetting started with qubits\n\n\n\nqc\n\ncode\n\n\n\n\n\n\n\n\n\nJun 3, 2025\n\n\nIraitz Montalban\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 1, 2025\n\n\nIraitz Montalban\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/qubits-code/index.html",
    "href": "posts/qubits-code/index.html",
    "title": "Coding my own simulator",
    "section": "",
    "text": "After all the concepts we have seen before like qubits and gates we should see them in action. See how some of the basis look, like:\n\nBasis \\(|0\\rangle\\) and \\(|1\\rangle\\) state.\nTensor product operations\nAnd the universal set of gates (\\(R_x(\\theta), R_x(\\theta), R_x(\\theta), P(\\phi)\\) phase shift gate and \\(CNOT\\) may suffice).\n\nWe can then create our own set of functions and objects to simulate those computations. Let go.\n\nFrom scratch\nWe would easily create basic vector structures for our quantum framework. The minimum unit is the qubit and in order to frame the potential quantum states it may hold we would need to create the computational basis set \\(\\{|0\\rangle, |1\\rangle \\}\\).\n\nimport numpy as np\nfrom qiskit.visualization import array_to_latex\n\nzero = [[1], [0]]\none = [[0], [1]]\n\narray_to_latex(array=zero, prefix='|0\\\\rangle = ', max_size=(10,10))\n\n\\[\n|0\\rangle =\n\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\n\\]\n\n\n\narray_to_latex(array=one, prefix='|1\\\\rangle = ', max_size=(10,10))\n\n\\[\n|1\\rangle =\n\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\n\\]\n\n\nNow lets try with some gates.\n\\[\nX = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right] \\quad\nH = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\n\\]\n\nX = [[0,1],[1,0]]\n\narray_to_latex(array=X, prefix='X = ', max_size=(10,10))\n\n\\[\nX =\n\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\n\\]\n\n\n\nhadamard = np.dot((1/(np.sqrt(2))), [[1, 1], [1, -1]])\n\narray_to_latex(array=hadamard, prefix='H = ', max_size=(10,10))\n\n\\[\nH =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\n\n\nWell, it is already taking shape. We can test if the outcome matches our expectations.\n\nsuperposition = np.dot(hadamard, zero)\n\narray_to_latex(array=superposition, prefix='H|0\\\\rangle = |+\\\\rangle = ', max_size=(10,10))\n\n\\[\nH|0\\rangle = |+\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\n\n\n\none = np.dot(X, zero)\n\narray_to_latex(array=one, prefix='X|0\\\\rangle = |1\\\\rangle = ', max_size=(10,10))\n\n\\[\nX|0\\rangle = |1\\rangle =\n\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\n\\]\n\n\nWe can scale it to a couple of qubits to see what we get. Let’s try to create on of the bell states we saw during class.\n\\[\n|\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\quad |\\Phi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle - |11\\rangle) \\\\\n|\\Psi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|01\\rangle + |10\\rangle) \\quad |\\Psi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|10\\rangle - |10\\rangle)\n\\]\nWe will need the CNOT gate for this.\n\nCNOT = [[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]\n\narray_to_latex(array=CNOT, prefix='CNOT = ', max_size=(10,10))\n\n\\[\nCNOT =\n\\begin{bmatrix}\n1 & 0 & 0 & 0  \\\\\n0 & 1 & 0 & 0  \\\\\n0 & 0 & 0 & 1  \\\\\n0 & 0 & 1 & 0  \\\\\n\\end{bmatrix}\n\\]\n\n\nWith this we will create a two qubit system, apply the Hadamard gate to the first one and the CNOT gate with the control over the first qubit as well.\n\n# Initial state\ninit_state = np.kron(zero, zero)\n\n# (I tensor Hadamard)\nHI = np.kron(hadamard, np.eye(2))\n\nWith that we can perform the full operation.\n\\[\nCNOT (I\\otimes H)|00\\rangle = |\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle\n\\]\n\npsi_1 = np.dot(HI, init_state)\npsi = np.dot(CNOT, psi_1)\n\narray_to_latex(array=psi, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2}  \\\\\n0  \\\\\n0  \\\\\n\\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\n\n\nThere you go. This is our entangled 2-qubit state. Building the whole formalism from scratch might be tedious, but it helps us understand every detail of it.\nOf course, in order to continue forward, we will take advantage of the collective effort and use some existing tools like QuTip to ease our way into quantum computing."
  },
  {
    "objectID": "posts/qubits/index.html",
    "href": "posts/qubits/index.html",
    "title": "Getting started with qubits",
    "section": "",
    "text": "Well, quantum computing. Really trendy topic. Fancy as it might be there are some really cool things we can learn from trying to challenge the status quo. Let’s see if we can get our heads around what quantum computing is and how to work with it."
  },
  {
    "objectID": "posts/qubits/index.html#measurement",
    "href": "posts/qubits/index.html#measurement",
    "title": "Getting started with qubits",
    "section": "Measurement",
    "text": "Measurement\nMeasuring quantum states is a necessary condition to extract information out of it, but by doing so we affect the system due to the collapse of the wave function. Observables (self-adjoint operators) are used to project the measurement of a given quantum state to one of its eigenvalues by using the closeness between quantum state and eigenvectors of the observable being used. The eigenvectors of the observable form an orthonormal basis for the Hilbert space, therefore each measure corresponds to a mapping to the eigenvectors comprising the basis.\nWe will see that a common observable used is the Pauli \\(\\sigma_z\\) matrix\n\\[\n\\sigma_z = \\left[\n\\begin{array}{cc}\n1 & 0 \\\\\n0 & -1\n\\end{array}\n\\right]\n\\]\nwhose decomposition is\n\\[\n\\sigma_z|0\\rangle = 1|0\\rangle \\rightarrow \\sigma_z|1\\rangle = -1|1\\rangle\n\\]\ntherefore, any potential measurement will be mapped to one of those two eigenvectors and its eigenvalue used as the outcome of the measurement. The basis set shown above is often known as the computational basis and it will become relevant when we move to actual implementations.\nFrom our previous state \\(|\\phi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle\\) and perform a measurement over the computational basis (\\(|0\\rangle,|1\\rangle\\)) where evidently the outcome would be \\(|0\\rangle\\) with \\(|\\alpha|^2\\) probability or \\(|1\\rangle\\) with \\(|\\beta|^2\\) probability. But more importantly, a single measurement, no matter how complex, entangled or superposed our state might be, will only be able to recover classical bits mapping two previously seen states (\\(|0\\rangle \\rightarrow 0\\) and \\(|1\\rangle \\rightarrow 1\\)).\nWhat happens after measurement is performed? Well, that is the trickiest part as the process of measuring obliges to our quantum state to position itself and make a choice. This means our quantum state after measurement will no longer be in a superposition state and will be the outcome of the previous measurement \\(|0\\rangle\\) for the remaining time period.\nIn order to fully grasp the statistics of the state we should find way to reproduce the state and perform enough measurements, so we can characterize its actual condition as much as we can out of the measurement statistics it presents. Measuring in the basis \\(\\{|0\\rangle, |1\\rangle\\}\\) (also called computational basis) may not be enough to capture the actual state. Therefore, a basis change is needed, but we will see that quantum devices only offer computational basis as the measuring basis. That means in certain cases we will need to rotate our qubits so that the basis change is artificially done.\nIf we would like to measure in the \\(\\{|+\\rangle, |-\\rangle\\}\\) basis then a rotation of \\(-\\pi / 2\\) in the Y axis will be needed. \\(\\{|i\\rangle, |-i\\rangle\\}\\) basis will require then a rotation over X axis of \\(\\pi / 2\\). That way we get to shift the reference point and measure according to our target axis."
  },
  {
    "objectID": "posts/qubits/index.html#superposition",
    "href": "posts/qubits/index.html#superposition",
    "title": "Getting started with qubits",
    "section": "Superposition",
    "text": "Superposition\nThis is one of the trickiest things to get when first approaching quantum computing as it is not so intuitive from our macroscopic perspective. It is also often misunderstood, we will try to make it clear. This is an example of a superposed state\n\\[\n|\\phi\\rangle =\n\\alpha |0\\rangle +\n\\beta |1\\rangle.\n\\]\nThe state is a superposed, no question on that, but our ability to perceive it is limited by the measurement procedure itself. We need to project our quantum state into one of the two potential states we can obtain (\\(|0\\rangle\\) or \\(|1\\rangle\\)). Sadly, when measuring only classical bits can be obtained (0 or 1) into our conventional machines, so no probability amplitude, no phase… information gets lost in the measurement process.\nThe probability histogram is created after a sequence of quantum state creations and measurements we often call SHOTS.\n\n\n\n\nCoin toss\n\n\n\nFor a series of measurements we have seen \\(|0\\rangle\\) state 50.6% and \\(|1\\rangle\\) state 49.4%. Definitely, looks superposed to me. It is hardly perceived in the classical regime were every basis state will be interpreted as its complementary classical bit, but quantum state holds a lot of information more than this simple binary choice.\nIn fact, both \\(\\alpha\\) and \\(\\beta\\) are complex numbers, that is why bloch sphere renders a more in detail expression of the state of a qubit. Sadly for us this is something we will never perceive from a real device but helps while building the formalism or creating algorithms.\n\n\n\n\nBloch sphere\n\n\n\nQuantum states can therefore be expressed also as:\n\\[\n|\\phi\\rangle = \\cos (\\theta/2) |0\\rangle + e^{i\\phi} \\sin (\\theta/2)|1\\rangle\n\\]\nwhich represents the sphere coordinates on the surface of the bloch sphere. It is more evident in this case that rendering simple bits will actually remove most of the information contained in the states when operating with them in the quantum regime.\nI think is enough for today but keep an eye, I will continue some of these explanations covering the concept of gates."
  }
]