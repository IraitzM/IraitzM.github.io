---
title: "Using QuTip"
author: "Iraitz Montalban"
date: "2025-06-24"
categories: [qc, code]
#image: "qc-bg.png"

format:
  html:
    code-fold: false
jupyter: python3
---

[QuTip](https://qutip.org/) is a superb Python library to simulate the dynamics of open quantum systems


```{python}
#| label: qutip-simulation

import scipy
import numpy as np
from qutip import Qobj, mesolve
from qutip import basis, tensor
from qutip.qip.operations import cnot

# Basis states
zero = basis(2,0)
one = basis(2,1)

# |10>
one_zero = tensor(one, zero)

# CNOT
hamiltonian = cnot().full()

# e^itH
u_generator = Qobj(1j * scipy.linalg.logm(hamiltonian), dims=[[2] * 2] * 2)

# Time range 0.0 -> 1.0
times = np.arange(0, 1.1, 0.1)

# \psi = H\psi_0
evolution = mesolve(u_generator, one_zero, times)
```


```{python}
#| label: initial-state

evolution.states[0]
```

This is our initial state. Where will it be at the next step of our evolution?

```{python}
#| label: step-one

evolution.states[1]
```

And at the end?

```{python}
#| label: final-state

evolution.states[-1]
```

Exactly, we have been able to simulate the whole evolution keeping the intermediate states to further study them. Neat.

We can try to make it closer to the example we performed [from scratch](../qubits-code/) to better understand how it works. 

```{python}
#| label: init

from qutip import basis, tensor

one = basis(2,1)
zero = basis(2,0)

one_zero = tensor(one, zero) # |10>
one_zero
```

```{python}
#| label: cnot

from qutip.qip.operations import cnot

cnot_matrix = cnot().full()
cnot_matrix
```

In fact, it allows us to do more than just the simple operations we envisioned. For example, we could generate the whole evolution over a period of time of the $U$ unitary generated for our Hamiltonian.

```{python}
#| label: hcnot

from qutip import identity
from qutip.qip.operations import hadamard_transform

# hamiltonian
hamiltonian =  cnot() * tensor(hadamard_transform(1), identity(2))
hamiltonian
```

```{python}
#| label: entanglement-operation

import numpy as np
import scipy
from qutip import Qobj, mesolve

# Initial state
init_state = tensor(zero, zero) # |00>

# e^itH
u_generator = Qobj(1j * scipy.linalg.logm(hamiltonian.full()), dims=[[2] * 2] * 2)

# Time range
times = np.arange(0, 1.1, 0.1)
evolution = mesolve(u_generator, init_state, times)
```

```{python}
evolution.states[0]
```

```{python}
from qiskit.visualization import array_to_latex

psi = np.round(evolution.states[-1].full(), decimals = 5)

array_to_latex(array=psi, prefix='|\\psi\\rangle = ', max_size=(10,10))
```

Well, having a theoretical framework may be a good option for simulating and doing some local experimentation but that will reach soon limitations when trying to scale it up. Our classical device won't be able to perform the whole system calculations and we might need to switch to actual quantum computers doing those. Therefore, we need to find a way to o so.

This is why some manufacturers have invested time and effort on creating open-source frameworks to be adopted by the community (and position themselves). Companies such as [IBM](https://qiskit.org/) or [AWS](https://github.com/aws/amazon-braket-sdk-python) have leveraged their own version that also allows for these programs to be sent to an end device that will perform the set of operations.